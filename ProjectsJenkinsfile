#!/bin/env groovy

/*******************************************************************************

    Utilities and helpers

*******************************************************************************/

/**
    Checks out latest SemVer-compatible tag available in specified repo
 **/
def cleanCheckout (repo_url, git_ref = "master") {
    checkout poll: false,
        scm: [$class: 'GitSCM', branches: [[name: git_ref]], doGenerateSubmoduleConfigurations: false,
              extensions: [[$class: 'CleanBeforeCheckout']], submoduleCfg: [], userRemoteConfigs: [[url: repo_url]]]

    def LATEST = sh (
        script: 'git tag -l | egrep "^v[0-9]+\\.[0-9]+\\.[0-9]+.*$" | sort --version-sort | tail -n 1',
        returnStdout: true
    ).trim()

    sh "git checkout ${LATEST}"
}

/**
    Utility to simplify repeating boilerplate of defining parallel steps
    over array of folders. Creates a map from @names array where each value
    is @action called with each name respectively while being wrapped in
    `dir(name)` statement.
 **/
def mapSteps (names, action) {
    def steps = [:]

    for (int i = 0; i < names.size(); ++i) {
        def name = names[i];
        steps[name] = { dir(name, { action(name) }) }
    }

    return steps
}

/*******************************************************************************

    Actions

    In Groovy it is not possible to define a "static" nested function and
    defining a closure wrongly captures a context, making it break `parallel`
    in weird ways.

    Because of that, all actions to be used with `mapSteps` are to be define
    here as global functions. Each function should be named in relation to stage
    is used in and take exactly one argument - directory name

*******************************************************************************/

def clone (name) {
    cleanCheckout "https://github.com/${name}.git"
}

/*******************************************************************************

    Stages

*******************************************************************************/

def dub_projects = [
   "Abscissa/libInputVisitor",
   "BlackEdder/ggplotd",
   "DerelictOrg/DerelictFT",
   "DerelictOrg/DerelictGL3",
   "DerelictOrg/DerelictGLFW3",
   "DerelictOrg/DerelictSDL2",
   "DlangScience/scid",
   "Hackerpilot/libdparse",
   "ariovistus/pyd",
   "atilaneves/unit-threaded",
   "d-gamedev-team/gfm",
   "dlang/dub",
   "economicmodeling/containers",
   "higgsjs/Higgs",
   "kyllingstad/zmqd",
   "lgvz/imageformats",
   "msgpack/msgpack-d",
   "msoucy/dproto",
   "nomad-software/dunit",
   "rejectedsoftware/diet-ng",
   "rejectedsoftware/vibe.d#libevent",
   "rejectedsoftware/vibe.d#libasync",
   "repeatedly/mustache-d",
   "s-ludwig/taggedalgebraic",
]

def runTest(name) {
    def n = name // to fix issues with closure
    def repo = name.split('#')[0]
    echo repo
    node {
        unstash name: "dlang-build"
        dir(n) {
            clone(repo)
            withEnv(["PATH=${env.WORKSPACE}/distribution/bin:${env.PATH}"]) {
                switch (n) {
                case 'higgsjs/Higgx':
                    sh 'make -C source test'
                    break;

                case 'higgsjs/Higgs':
                    sh 'make -C source test'
                    break;

                case 'rejectedsoftware/vibe.d#libevent':
                    sh 'DC=dmd VIBED_DRIVER=libevent BUILD_EXAMPLE=1 RUN_TEST=1 ./travis-ci.sh'
                    break;

                case 'rejectedsoftware/vibe.d#libasync':
                    sh 'DC=dmd VIBED_DRIVER=libasync BUILD_EXAMPLE=0 RUN_TEST=0 ./travis-ci.sh'
                    break;

                case 'BlackEdder/ggplotd':
                    // workaround https://github.com/BlackEdder/ggplotd/issues/34
                    sh 'sed -i \'s|auto seed = unpredictableSeed|auto seed = 54321|\' source/ggplotd/example.d'
                    sh 'dub test'
                    break;

                default:
                    sh 'dub test'
                    break;
                }
            }
        }
    }
}

stage('Test Projects') {
    parallel mapSteps(dub_projects, this.&runTest)
}
